const express = require('express');
const http = require('http');
const socketIO = require('socket.io');
const cors = require('cors');
const mongoose = require('mongoose');
require('dotenv').config();

const app = express();
const server = http.createServer(app);
const io = socketIO(server, {
  cors: {
    origin: process.env.CLIENT_URL || "http://localhost:5173",
    methods: ["GET", "POST"]
  }
});

// Middleware
app.use(cors());
app.use(express.json());

// MongoDB Connection
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/typing-game')
.then(() => console.log('âœ… MongoDB Ù…ØªØµÙ„'))
.catch(err => console.log('âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ MongoDB:', err));

// Models
const GameResult = mongoose.model('GameResult', {
  playerName: String,
  wpm: Number,
  accuracy: Number,
  date: { type: Date, default: Date.now }
});

// Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
const rooms = new Map();

// Ù‚ÙˆØ§Ø¦Ù… Ø§Ù„ÙØ¦Ø§Øª
const categories = {
  animals: [
    'Ù‚Ø·', 'ÙƒÙ„Ø¨', 'Ø£Ø³Ø¯', 'ÙÙŠÙ„', 'Ù†Ù…Ø±', 'Ø¯Ø¨', 'Ø°Ø¦Ø¨', 'Ø«Ø¹Ù„Ø¨', 'Ø£Ø±Ù†Ø¨', 'ØºØ²Ø§Ù„', 
    'Ø²Ø±Ø§ÙØ©', 'Ø­Ù…Ø§Ø±', 'Ø­ØµØ§Ù†', 'Ø¬Ù…Ù„', 'Ø¨Ù‚Ø±Ø©', 'Ø®Ø±ÙˆÙ', 'Ù…Ø§Ø¹Ø²', 'Ø¯Ø¬Ø§Ø¬Ø©', 'Ø¨Ø·Ø©', 'Ø¥ÙˆØ²Ø©',
    'Ù†Ø³Ø±', 'ØµÙ‚Ø±', 'Ø­Ù…Ø§Ù…Ø©', 'Ø¹ØµÙÙˆØ±', 'Ø¨Ø¨ØºØ§Ø¡', 'Ø³Ù…ÙƒØ©', 'Ù‚Ø±Ø´', 'Ø­ÙˆØª', 'Ø¯ÙˆÙ„ÙÙŠÙ†', 'Ø£Ø®Ø·Ø¨ÙˆØ·',
    'ÙØ£Ø±', 'Ù‚Ù†ÙØ°', 'Ø³Ù„Ø­ÙØ§Ø©', 'Ø«Ø¹Ø¨Ø§Ù†', 'ØªÙ…Ø³Ø§Ø­', 'Ø¶ÙØ¯Ø¹', 'Ù†Ø­Ù„Ø©', 'Ù†Ù…Ù„Ø©', 'ÙØ±Ø§Ø´Ø©', 'Ø¹Ù†ÙƒØ¨ÙˆØª',
    'Ø®ÙØ§Ø´', 'ÙƒÙ†ØºØ±', 'Ø¨Ø§Ù†Ø¯Ø§', 'Ù‚Ø±Ø¯', 'ØºÙˆØ±ÙŠÙ„Ø§', 'ÙÙ‡Ø¯', 'Ø¶Ø¨Ø¹', 'ÙˆØ­ÙŠØ¯ Ø§Ù„Ù‚Ø±Ù†', 'ÙØ±Ø³ Ø§Ù„Ù†Ù‡Ø±', 'Ø¯ÙˆØ¯Ø©'
  ],
  fruits: [
    'ØªÙØ§Ø­', 'Ù…ÙˆØ²', 'Ø¨Ø±ØªÙ‚Ø§Ù„', 'Ø¹Ù†Ø¨', 'ÙØ±Ø§ÙˆÙ„Ø©', 'Ù…Ø§Ù†Ø¬Ùˆ', 'Ø£Ù†Ø§Ù†Ø§Ø³', 'Ø¨Ø·ÙŠØ®', 'Ø´Ù…Ø§Ù…', 'Ø®ÙˆØ®',
    'ÙƒÙ…Ø«Ø±Ù‰', 'Ù„ÙŠÙ…ÙˆÙ†', 'Ø±Ù…Ø§Ù†', 'ÙƒÙŠÙˆÙŠ', 'ØªÙŠÙ†', 'ØªÙˆØª', 'Ù…Ø´Ù…Ø´', 'Ø¬ÙˆØ§ÙØ©', 'Ø¨Ø§Ø¨Ø§ÙŠ', 'ØªÙ…Ø±',
    'ÙƒØ±Ø²', 'Ø¨Ù„Ø­', 'ÙŠÙˆØ³ÙÙŠ', 'Ø¬Ø±ÙŠØ¨ ÙØ±ÙˆØª', 'Ø®ÙˆØ®', 'Ø¯Ø±Ø§Ù‚', 'Ù†ÙƒØªØ§Ø±ÙŠÙ†', 'Ø¬ÙˆØ² Ø§Ù„Ù‡Ù†Ø¯', 'Ø£ÙÙˆÙƒØ§Ø¯Ùˆ', 'ØªÙ†ÙŠÙ†',
    'Ø¨Ø§Ø´Ù† ÙØ±ÙˆØª', 'Ù„ÙŠØªØ´ÙŠ', 'Ø±Ø§Ù…Ø¨ÙˆØªØ§Ù†', 'ÙƒØ§ÙƒØ§', 'ÙƒÙ…ÙƒÙˆØ§Øª', 'Ø¨Ù„ÙˆØ¨ÙŠØ±ÙŠ', 'Ø±Ø§Ø³Ø¨ÙŠØ±ÙŠ', 'Ø¨Ù„Ø§Ùƒ Ø¨ÙŠØ±ÙŠ', 'ÙØ±ÙŠØ²', 'Ø³ÙØ±Ø¬Ù„',
    'Ù†Ø¨Ù‚', 'Ø¹Ù†Ø§Ø¨', 'Ø¯ÙˆÙ…', 'Ø¨ÙˆÙ…Ù„ÙŠ', 'ÙŠØ¯ Ø¨ÙˆØ°Ø§', 'Ø§ÙƒÙŠ', 'ÙƒÙˆØ±Ø³ÙˆÙ„', 'Ø¯ÙˆØ±ÙŠØ§Ù†', 'Ù…Ø§Ù†Ø¬ÙˆØ³ØªÙŠÙ†', 'Ù„ÙˆÙ†Ø¬Ø§Ù†'
  ],
  math: []
};

// ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
const drawingWords = [
  'Ù‚Ø·Ø©', 'ÙƒÙ„Ø¨', 'Ø£Ø³Ø¯', 'ÙÙŠÙ„', 'Ø²Ø±Ø§ÙØ©', 'Ù‚Ø±Ø¯', 'Ø¯Ø¨', 'Ø£Ø±Ù†Ø¨', 'Ø³Ù…ÙƒØ©', 'Ø·Ø§Ø¦Ø±',
  'Ø­ØµØ§Ù†', 'Ø¬Ù…Ù„', 'Ø¨Ù‚Ø±Ø©', 'Ø®Ø±ÙˆÙ', 'Ø¯Ø¬Ø§Ø¬Ø©', 'Ø¨Ø·Ø©', 'Ù†Ù…Ø±', 'Ø°Ø¦Ø¨', 'Ø«Ø¹Ù„Ø¨', 'ØºØ²Ø§Ù„',
  'ÙƒØ±Ø©', 'ÙƒØªØ§Ø¨', 'Ù‚Ù„Ù…', 'Ø³ÙŠØ§Ø±Ø©', 'Ø¨ÙŠØª', 'Ø´Ø¬Ø±Ø©', 'Ø´Ù…Ø³', 'Ù‚Ù…Ø±', 'Ù†Ø¬Ù…Ø©', 'Ø³Ø­Ø§Ø¨Ø©',
  'Ù…Ø¸Ù„Ø©', 'Ù†Ø¸Ø§Ø±Ø©', 'Ø³Ø§Ø¹Ø©', 'Ù‡Ø§ØªÙ', 'Ø­Ø§Ø³ÙˆØ¨', 'ØªÙ„ÙØ§Ø²', 'ÙƒØ±Ø³ÙŠ', 'Ø·Ø§ÙˆÙ„Ø©', 'Ø¨Ø§Ø¨', 'Ù†Ø§ÙØ°Ø©',
  'ØªÙØ§Ø­Ø©', 'Ù…ÙˆØ²Ø©', 'Ø¨Ø±ØªÙ‚Ø§Ù„Ø©', 'Ø¹Ù†Ø¨', 'Ø¨Ø·ÙŠØ®', 'Ø®Ø¨Ø²', 'Ø¬Ø¨Ù†', 'Ø­Ù„ÙŠØ¨', 'Ù…Ø§Ø¡', 'Ø¹ØµÙŠØ±',
  'ÙƒØ¹ÙƒØ©', 'Ø¢ÙŠØ³ ÙƒØ±ÙŠÙ…', 'Ø¨ÙŠØªØ²Ø§', 'Ø¨Ø±Ø¬Ø±', 'Ù…Ø¹ÙƒØ±ÙˆÙ†Ø©', 'Ø£Ø±Ø²', 'Ø¯Ø¬Ø§Ø¬', 'Ø³Ù…Ùƒ', 'Ø¨ÙŠØ¶', 'Ø³Ù„Ø·Ø©',
  'Ø¬Ø¨Ù„', 'Ø¨Ø­Ø±', 'Ù†Ù‡Ø±', 'ØµØ­Ø±Ø§Ø¡', 'ØºØ§Ø¨Ø©', 'Ø²Ù‡Ø±Ø©', 'ÙˆØ±Ø¯Ø©', 'Ø¹Ø´Ø¨', 'Ø­Ø¬Ø±', 'Ø±Ù…Ù„',
  'Ù…Ø·Ø±', 'Ø«Ù„Ø¬', 'Ø¨Ø±Ù‚', 'Ø±Ø¹Ø¯', 'Ù‚ÙˆØ³ Ù‚Ø²Ø­', 'Ø±ÙŠØ­', 'Ù†Ø§Ø±', 'Ø¯Ø®Ø§Ù†', 'Ù…Ø§Ø¡', 'ØªØ±Ø§Ø¨',
  'ÙƒØ±Ø© Ù‚Ø¯Ù…', 'Ø³Ù„Ø©', 'ØªÙ†Ø³', 'Ø³Ø¨Ø§Ø­Ø©', 'Ø¬Ø±ÙŠ', 'Ù‚ÙØ²', 'Ø¯Ø±Ø§Ø¬Ø©', 'Ù„Ø¹Ø¨Ø©', 'Ù…ÙˆØ³ÙŠÙ‚Ù‰', 'Ø±Ù‚Øµ',
  'Ù…ÙØªØ§Ø­', 'Ù…Ø·Ø±Ù‚Ø©', 'Ù…Ù†Ø´Ø§Ø±', 'Ù…Ø³Ù…Ø§Ø±', 'Ø­Ø¨Ù„', 'ØµÙ†Ø¯ÙˆÙ‚', 'ÙƒÙŠØ³', 'Ø²Ø¬Ø§Ø¬Ø©', 'ÙƒÙˆØ¨', 'ØµØ­Ù†'
];

function getRandomWords(count) {
  const shuffled = [...drawingWords].sort(() => Math.random() - 0.5);
  return shuffled.slice(0, count);
}

const categoryInfo = [
  { id: 'animals', name: 'Ø­ÙŠÙˆØ§Ù†Ø§Øª', icon: 'ğŸ±', duration: 20 },
  { id: 'fruits', name: 'ÙÙˆØ§ÙƒÙ‡', icon: 'ğŸ', duration: 20 },
  { id: 'math', name: 'Ø¹Ù…Ù„ÙŠØ§Øª Ø­Ø³Ø§Ø¨ÙŠØ©', icon: 'â—', duration: 20 }
];

function normalizeText(text) {
  return text
    .trim()
    .toLowerCase()
    .replace(/Ø©/g, 'Ù‡')
    .replace(/Ø£|Ø¥|Ø¢/g, 'Ø§')
    .replace(/\s+/g, ' ');
}

function generateMathQuestion() {
  const operations = ['+', '-', 'Ã—', 'Ã·'];
  const operation = operations[Math.floor(Math.random() * operations.length)];
  
  let num1, num2, answer;
  
  if (operation === '+') {
    num1 = Math.floor(Math.random() * 50) + 1;
    num2 = Math.floor(Math.random() * 50) + 1;
    answer = num1 + num2;
  } else if (operation === '-') {
    num1 = Math.floor(Math.random() * 50) + 20;
    num2 = Math.floor(Math.random() * num1) + 1;
    answer = num1 - num2;
  } else if (operation === 'Ã—') {
    num1 = Math.floor(Math.random() * 12) + 1;
    num2 = Math.floor(Math.random() * 12) + 1;
    answer = num1 * num2;
  } else {
    num2 = Math.floor(Math.random() * 10) + 2;
    answer = Math.floor(Math.random() * 10) + 1;
    num1 = num2 * answer;
  }
  
  return {
    question: `${num1} ${operation} ${num2}`,
    answer: answer
  };
}

// ================ API Endpoints ================

app.post('/api/game/create', (req, res) => {
  const { playerName, gameType } = req.body;
  
  if (!playerName) {
    return res.status(400).json({ error: 'Ø§Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù…Ø·Ù„ÙˆØ¨' });
  }

  const roomId = generateRoomId();
  
  const roomData = {
    players: [{
      id: null,
      name: playerName,
      score: 0,
      answers: []
    }],
    status: 'waiting',
    gameType: gameType || 'categories',
    createdAt: Date.now()
  };

  if (gameType === 'drawing') {
    roomData.drawingWords = [];
    roomData.currentRound = 0;
    roomData.currentDrawer = 0;
    roomData.guessedPlayers = [];
  } else {
    roomData.currentCategory = 0;
    roomData.usedAnswers = [];
  }
  
  rooms.set(roomId, roomData);

  res.json({ 
    roomId,
    gameType: gameType || 'categories',
    message: 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØºØ±ÙØ© Ø¨Ù†Ø¬Ø§Ø­' 
  });
});

app.post('/api/game/join/:roomId', (req, res) => {
  const { roomId } = req.params;
  const { playerName } = req.body;

  if (!playerName) {
    return res.status(400).json({ error: 'Ø§Ø³Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù…Ø·Ù„ÙˆØ¨' });
  }

  const room = rooms.get(roomId);

  if (!room) {
    return res.status(404).json({ error: 'Ø§Ù„ØºØ±ÙØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©' });
  }

  if (room.status !== 'waiting') {
    return res.status(400).json({ error: 'Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¨Ø¯Ø£Øª Ø¨Ø§Ù„ÙØ¹Ù„' });
  }

  if (room.players.length >= 4) {
    return res.status(400).json({ error: 'Ø§Ù„ØºØ±ÙØ© Ù…Ù…ØªÙ„Ø¦Ø©' });
  }

  room.players.push({
    id: null,
    name: playerName,
    score: 0,
    answers: []
  });

  res.json({ 
    roomId,
    gameType: room.gameType,
    players: room.players.map(p => ({ name: p.name })),
    message: 'ØªÙ… Ø§Ù„Ø§Ù†Ø¶Ù…Ø§Ù… Ø¨Ù†Ø¬Ø§Ø­' 
  });
});

app.get('/api/leaderboard', async (req, res) => {
  try {
    const topPlayers = await GameResult.find()
      .sort({ wpm: -1 })
      .limit(10)
      .select('playerName wpm accuracy date');
    
    res.json(topPlayers);
  } catch (error) {
    res.status(500).json({ error: 'Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª' });
  }
});

app.post('/api/game/result', async (req, res) => {
  try {
    const { playerName, wpm, accuracy } = req.body;

    if (!playerName || wpm === undefined || accuracy === undefined) {
      return res.status(400).json({ error: 'Ø¨ÙŠØ§Ù†Ø§Øª Ù†Ø§Ù‚ØµØ©' });
    }

    const result = new GameResult({ playerName, wpm, accuracy });
    await result.save();

    res.json({ message: 'ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù†ØªÙŠØ¬Ø©', result });
  } catch (error) {
    res.status(500).json({ error: 'Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ù†ØªÙŠØ¬Ø©' });
  }
});

// ================ Socket.IO ================

io.on('connection', (socket) => {
  console.log('ğŸŸ¢ Ù„Ø§Ø¹Ø¨ Ø¬Ø¯ÙŠØ¯ Ù…ØªØµÙ„:', socket.id);

  // ============= Ø¯ÙˆØ§Ù„ Ù„Ø¹Ø¨Ø© Ø§Ù„ÙØ¦Ø§Øª =============
  
  const startCategory = (roomId) => {
    const room = rooms.get(roomId);
    if (!room) return;

    const category = categoryInfo[room.currentCategory];
    
    let mathQuestion = null;
    if (category.id === 'math') {
      mathQuestion = generateMathQuestion();
      room.currentMathQuestion = mathQuestion;
    }
    
    // âœ… Ø­ÙØ¸ ÙˆÙ‚Øª Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
    room.categoryStartTime = Date.now();
    
    io.to(roomId).emit('category-started', {
      category: category,
      categoryNumber: room.currentCategory + 1,
      totalCategories: categoryInfo.length,
      mathQuestion: mathQuestion,
      startTime: room.categoryStartTime // âœ… Ø¥Ø±Ø³Ø§Ù„ ÙˆÙ‚Øª Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
    });

    // âœ… Ø§Ø³ØªØ®Ø¯Ø§Ù… setTimeout Ù…Ø¹ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„ÙØ¹Ù„ÙŠ
    const timeoutDuration = category.duration * 1000;
    
    room.categoryTimer = setTimeout(() => {
      endCategory(roomId);
    }, timeoutDuration);
  };

  const endCategory = (roomId) => {
  const room = rooms.get(roomId);
  if (!room) return;

  room.currentCategory++;

  if (room.currentCategory < categoryInfo.length) {
    room.usedAnswers = [];
    
    setTimeout(() => {
      startCategory(roomId);
    }, 200);
  } else {
    room.status = 'finished';
    room.playersReady = [];
    room.playersGameChoice = new Map();
    
    const results = room.players
      .sort((a, b) => b.score - a.score)
      .map((p, index) => ({
        rank: index + 1,
        name: p.name,
        score: p.score
      }));
    
    console.log(`ğŸ“¤ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù„Ù„ØºØ±ÙØ© ${roomId}:`, { results, roomId });
    
    // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù‡ÙˆØ³Øª (Ø£ÙˆÙ„ Ù„Ø§Ø¹Ø¨ ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ©)
    const hostName = room.players[0].name;
    
    // âœ… Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„ØºØ±ÙØ© ÙƒÙ„Ù‡Ø§ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø¥Ø±Ø³Ø§Ù„ ÙØ±Ø¯ÙŠ
    room.players.forEach(player => {
      const isHost = player.name === hostName;
      console.log(`ğŸ“¨ Ø¥Ø±Ø³Ø§Ù„ Ù„Ù€ ${player.name} (${player.id}) - isHost: ${isHost}`);
      
      // Ø¥Ø±Ø³Ø§Ù„ Ø¨Ø·Ø±ÙŠÙ‚ØªÙŠÙ† Ù„Ù„ØªØ£ÙƒØ¯
      if (player.id) {
        io.to(player.id).emit('game-finished', {
          results,
          roomId,
          isHost
        });
      }
    });
    
    // âœ… Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„ØºØ±ÙØ© ÙƒØ§Ù…Ù„Ø© ÙƒÙ€ backup
    io.to(roomId).emit('game-finished', {
      results,
      roomId,
      hostName // Ø£Ø±Ø³Ù„ Ø§Ø³Ù… Ø§Ù„Ù‡ÙˆØ³Øª Ø¹Ø´Ø§Ù† Ø§Ù„Ù€ client ÙŠØ­Ø¯Ø¯
    });
  }
};

  // ============= Ø¯ÙˆØ§Ù„ Ù„Ø¹Ø¨Ø© Ø§Ù„Ø±Ø³Ù… =============

  const startDrawingRound = (roomId) => {
  const room = rooms.get(roomId);
  if (!room || room.gameType !== 'drawing') return;

  const drawer = room.players[room.currentDrawer];
  const word = room.drawingWords[room.currentDrawer];

  room.guessedPlayers = [];
  room.roundStartTime = Date.now();
  room.roundEnded = false;
  
  room.players.forEach(player => {
    player.remainingGuesses = 5;
    player.hasFinishedGuessing = false;
  });

  io.to(drawer.id).emit('your-turn-to-draw', {
    word: word,
    round: room.currentRound + 1,
    totalRounds: room.players.length
  });

  room.players.forEach(player => {
    if (player.id !== drawer.id) {
      io.to(player.id).emit('someone-drawing', {
        drawerName: drawer.name,
        round: room.currentRound + 1,
        totalRounds: room.players.length
      });
    }
  });

  // â±ï¸ ØªØ§ÙŠÙ…Ø± Ø§Ù„Ø¬ÙˆÙ„Ø© - ÙŠÙ†Ù‡ÙŠ Ø§Ù„Ø¬ÙˆÙ„Ø© Ù„Ù…Ø§ Ø§Ù„ÙˆÙ‚Øª ÙŠØ®Ù„Øµ
  room.roundTimer = setTimeout(() => {
    console.log(`â° Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„ÙˆÙ‚Øª ÙÙŠ Ø§Ù„ØºØ±ÙØ© ${roomId}`);
    if (!room.roundEnded) {
      endDrawingRound(roomId, 'timeout');
    }
  }, 60000); // 60 Ø«Ø§Ù†ÙŠØ©
};

  const checkRoundEnd = (roomId) => {
  const room = rooms.get(roomId);
  if (!room || room.gameType !== 'drawing' || room.roundEnded) return;

  const drawer = room.players[room.currentDrawer];
  const otherPlayers = room.players.filter(p => p.id !== drawer.id);

  // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ù„ÙŠ Ø®Ù„ØµÙˆØ§ (Ø¥Ù…Ø§ Ø®Ù…Ù†ÙˆØ§ ØµØ­ Ø£Ùˆ Ø®Ù„ØµØª Ù…Ø­Ø§ÙˆÙ„Ø§ØªÙ‡Ù…)
  const finishedPlayers = otherPlayers.filter(p => 
    room.guessedPlayers.includes(p.id) || p.hasFinishedGuessing
  );

  console.log(`ğŸ” Ø§Ù„ØºØ±ÙØ© ${roomId}: ${finishedPlayers.length}/${otherPlayers.length} Ø®Ù„ØµÙˆØ§`);

  // âœ… Ø¥Ø°Ø§ ÙƒÙ„ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø®Ù„ØµÙˆØ§ØŒ Ø£Ù†Ù‡ÙŠ Ø§Ù„Ø¬ÙˆÙ„Ø© ÙÙˆØ±Ø§Ù‹
  if (finishedPlayers.length === otherPlayers.length) {
    console.log(`âœ… Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø®Ù„ØµÙˆØ§ ÙÙŠ Ø§Ù„ØºØ±ÙØ© ${roomId} - Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¬ÙˆÙ„Ø©`);
    endDrawingRound(roomId, 'all_finished');
  }
  };

  const endDrawingRound = (roomId, reason = 'normal') => {
    const room = rooms.get(roomId);
    if (!room || room.gameType !== 'drawing' || room.roundEnded) return;

    room.roundEnded = true;
    
    if (room.roundTimer) {
      clearTimeout(room.roundTimer);
      room.roundTimer = null;
    }

    const word = room.drawingWords[room.currentDrawer];
    
    console.log(`ğŸ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø¬ÙˆÙ„Ø© ÙÙŠ Ø§Ù„ØºØ±ÙØ© ${roomId} - Ø§Ù„Ø³Ø¨Ø¨: ${reason}`);
    
    io.to(roomId).emit('round-ended', {
      word: word,
      scores: room.players.map(p => ({
        name: p.name,
        score: p.score
      }))
    });

    room.currentRound++;
    room.currentDrawer++;

    if (room.currentRound >= room.players.length) {
      room.status = 'finished';
      room.playersReady = [];
      room.playersGameChoice = new Map();
      
      const results = room.players
        .sort((a, b) => b.score - a.score)
        .map((p, index) => ({
          rank: index + 1,
          name: p.name,
          score: p.score
        }));
      
      console.log(`ğŸ“¤ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù„Ù„ØºØ±ÙØ© ${roomId}:`, { results, roomId });
      
      const hostName = room.players[0].name;
      
      setTimeout(() => {
        // âœ… Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„ØºØ±ÙØ© ÙƒÙ„Ù‡Ø§
        room.players.forEach(player => {
          const isHost = player.name === hostName;
          console.log(`ğŸ“¨ Ø¥Ø±Ø³Ø§Ù„ Ù„Ù€ ${player.name} (${player.id}) - isHost: ${isHost}`);
          
          if (player.id) {
            io.to(player.id).emit('game-finished', {
              results,
              roomId,
              isHost
            });
          }
        });
        
        // âœ… backup - Ø¥Ø±Ø³Ø§Ù„ Ù„Ù„ØºØ±ÙØ©
        io.to(roomId).emit('game-finished', {
          results,
          roomId,
          hostName
        });
      }, 2000);
      
    } else {
      setTimeout(() => {
        startDrawingRound(roomId);
      }, 3000);
    }
  };

  // ============= Events Ø¹Ø§Ù…Ø© =============

  socket.on('join-room', ({ roomId, playerName }) => {
    const room = rooms.get(roomId);
    
    if (!room) {
      socket.emit('error', 'Ø§Ù„ØºØ±ÙØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©');
      return;
    }

    const player = room.players.find(p => p.name === playerName && !p.id);
    if (player) {
      player.id = socket.id;
    }

    socket.join(roomId);
    socket.roomId = roomId;
    socket.playerName = playerName;

    io.to(roomId).emit('room-update', {
      players: room.players.map(p => ({ name: p.name, score: p.score || 0 })),
      status: room.status,
      gameType: room.gameType,
      wordMode: room.wordMode || 'player'
    });

    io.to(socket.id).emit('scores-update', {
      scores: room.players.map(p => ({
        name: p.name,
        score: p.score || 0
      }))
    });

    console.log(`ğŸ“¥ ${playerName} Ø§Ù†Ø¶Ù… Ù„Ù„ØºØ±ÙØ© ${roomId}`);
  });

  socket.on('get-scores', ({ roomId }) => {
    const room = rooms.get(roomId);
    if (room) {
      io.to(socket.id).emit('scores-update', {
        scores: room.players.map(p => ({
          name: p.name,
          score: p.score || 0
        }))
      });
    }
  });

  socket.on('request-category', ({ roomId }) => {
    const room = rooms.get(roomId);
    if (room && room.status === 'playing' && room.gameType === 'categories' && room.currentCategory < categoryInfo.length) {
      const category = categoryInfo[room.currentCategory];
      const response = {
        category: category,
        categoryNumber: room.currentCategory + 1,
        totalCategories: categoryInfo.length
      };
      
      if (category.id === 'math' && room.currentMathQuestion) {
        response.mathQuestion = room.currentMathQuestion;
      }
      
      io.to(socket.id).emit('category-started', response);
    }
  });

  socket.on('start-game', ({ wordMode }) => {
    const roomId = socket.roomId;
    const room = rooms.get(roomId);

    if (!room || room.status !== 'waiting') return;

    room.status = 'playing';
    room.startTime = Date.now();
    room.wordMode = wordMode || 'player';

    if (room.gameType === 'drawing') {
      room.currentRound = 0;
      room.currentDrawer = 0;

      if (wordMode === 'random') {
        room.drawingWords = getRandomWords(room.players.length);
        console.log('ğŸ² ØªÙ… ØªÙˆÙ„ÙŠØ¯ ÙƒÙ„Ù…Ø§Øª Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©:', room.drawingWords);
      }

      let countdown = 3;
      const countdownInterval = setInterval(() => {
        io.to(roomId).emit('countdown', countdown);
        countdown--;

        if (countdown < 0) {
          clearInterval(countdownInterval);
          
          if (wordMode === 'random') {
            setTimeout(() => startDrawingRound(roomId), 100);
          }
        }
      }, 1000);

    } else {
      room.currentCategory = 0;
      room.usedAnswers = [];

      let countdown = 3;
      const countdownInterval = setInterval(() => {
        io.to(roomId).emit('countdown', countdown);
        countdown--;

        if (countdown < 0) {
          clearInterval(countdownInterval);
          setTimeout(() => startCategory(roomId), 100);
        }
      }, 1000);
    }
  });

  socket.on('change-word-mode', ({ roomId, wordMode }) => {
    const room = rooms.get(roomId);
    if (room && room.status === 'waiting') {
      room.wordMode = wordMode;
      io.to(roomId).emit('word-mode-updated', { wordMode });
      console.log(`ğŸ”„ ØªÙ… ØªØºÙŠÙŠØ± Ù†Ø¸Ø§Ù… Ø§Ù„ÙƒÙ„Ù…Ø§Øª ÙÙŠ Ø§Ù„ØºØ±ÙØ© ${roomId} Ø¥Ù„Ù‰: ${wordMode}`);
    }
  });

  socket.on('submit-answer', ({ answer }) => {
    const roomId = socket.roomId;
    const room = rooms.get(roomId);
    
    if (!room || room.status !== 'playing') return;

    const player = room.players.find(p => p.id === socket.id);
    if (!player) return;

    if (room.gameType === 'categories') {
      const category = categoryInfo[room.currentCategory];
      const normalizedAnswer = normalizeText(answer);
      
      let isCorrect = false;
      
      if (category.id === 'math') {
        const userAnswer = parseFloat(answer.trim());
        if (!isNaN(userAnswer) && room.currentMathQuestion) {
          if (Math.abs(userAnswer - room.currentMathQuestion.answer) < 0.01) {
            isCorrect = true;
            room.currentMathQuestion = generateMathQuestion();
            
            io.to(roomId).emit('new-math-question', {
              mathQuestion: room.currentMathQuestion
            });
          }
        }
      } else {
        const validAnswers = categories[category.id].map(a => normalizeText(a));
        const usedAnswersNormalized = room.usedAnswers.map(a => normalizeText(a));
        
        if (validAnswers.includes(normalizedAnswer) && !usedAnswersNormalized.includes(normalizedAnswer)) {
          isCorrect = true;
          room.usedAnswers.push(answer.trim());
        }
      }

      if (isCorrect) {
        player.score++;
      }

      io.to(roomId).emit('answer-result', {
        playerName: player.name,
        answer: isCorrect ? null : answer.trim(),
        isCorrect: isCorrect,
        newScore: player.score
      });

      io.to(roomId).emit('scores-update', {
        scores: room.players.map(p => ({
          name: p.name,
          score: p.score
        }))
      });
    }
  });

  socket.on('request-drawing-state', ({ roomId }) => {
    const room = rooms.get(roomId);
    if (room && room.status === 'playing' && room.gameType === 'drawing') {
      const drawer = room.players[room.currentDrawer];
      
      if (drawer) {
        if (drawer.id === socket.id) {
          const word = room.drawingWords[room.currentDrawer];
          io.to(socket.id).emit('your-turn-to-draw', {
            word: word,
            round: room.currentRound + 1,
            totalRounds: room.players.length
          });
        } else {
          io.to(socket.id).emit('someone-drawing', {
            drawerName: drawer.name,
            round: room.currentRound + 1,
            totalRounds: room.players.length
          });
        }

        io.to(socket.id).emit('scores-update', {
          scores: room.players.map(p => ({
            name: p.name,
            score: p.score || 0
          }))
        });
      }
    }
  });

  socket.on('submit-word', ({ word }) => {
    const roomId = socket.roomId;
    const room = rooms.get(roomId);
    
    if (!room || room.gameType !== 'drawing') return;

    const player = room.players.find(p => p.id === socket.id);
    if (!player) return;

    room.drawingWords.push(word.trim());

    io.to(roomId).emit('words-update', {
      wordsCount: room.drawingWords.length,
      totalPlayers: room.players.length
    });

    console.log(`ğŸ“ ${player.name} Ø£Ø¯Ø®Ù„ ÙƒÙ„Ù…Ø© ÙÙŠ Ø§Ù„ØºØ±ÙØ© ${roomId}`);
  });

  socket.on('draw', ({ roomId, drawData }) => {
    socket.to(roomId).emit('drawing', drawData);
  });

  socket.on('clear-canvas', ({ roomId }) => {
    socket.to(roomId).emit('canvas-cleared');
  });

  socket.on('submit-guess', ({ guess }) => {
  const roomId = socket.roomId;
  const room = rooms.get(roomId);
  
  if (!room || room.gameType !== 'drawing' || room.status !== 'playing' || room.roundEnded) return;

  const player = room.players.find(p => p.id === socket.id);
  if (!player) return;

  const drawer = room.players[room.currentDrawer];
  if (player.id === drawer.id) return;

  // âœ… Ù…Ù†Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù…Ù† Ø§Ù„ØªØ®Ù…ÙŠÙ† Ø¥Ø°Ø§ Ø®Ù„ØµØª Ù…Ø­Ø§ÙˆÙ„Ø§ØªÙ‡ Ø£Ùˆ Ø®Ù…Ù† ØµØ­
  if (room.guessedPlayers.includes(player.id) || player.hasFinishedGuessing) {
    return;
  }

  if (!player.remainingGuesses || player.remainingGuesses <= 0) {
    io.to(socket.id).emit('no-guesses-left', {
      message: 'Ù„Ù‚Ø¯ Ø§Ø³ØªÙ†ÙØ°Øª Ù…Ø­Ø§ÙˆÙ„Ø§ØªÙƒ Ø§Ù„Ù€ 5!'
    });
    return;
  }

  const correctWord = room.drawingWords[room.currentDrawer];
  const normalizedGuess = normalizeText(guess);
  const normalizedWord = normalizeText(correctWord);

  if (normalizedGuess === normalizedWord) {
    // âœ… ØªØ®Ù…ÙŠÙ† ØµØ­ÙŠØ­
    room.guessedPlayers.push(player.id);
    player.hasFinishedGuessing = true;
    player.score++;
    drawer.score++;

    io.to(roomId).emit('correct-guess', {
      playerName: player.name,
      scores: room.players.map(p => ({
        name: p.name,
        score: p.score
      }))
    });

    console.log(`âœ… ${player.name} Ø®Ù…Ù† ØµØ­ ÙÙŠ Ø§Ù„ØºØ±ÙØ© ${roomId}`);
    
    // ğŸ” ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒÙ„ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø®Ù„ØµÙˆØ§
    checkRoundEnd(roomId);
    
  } else {
    // âŒ ØªØ®Ù…ÙŠÙ† Ø®Ø§Ø·Ø¦
    player.remainingGuesses--;

    io.to(roomId).emit('wrong-guess', {
      playerName: player.name,
      guess: guess,
      remainingGuesses: player.remainingGuesses
    });

    io.to(socket.id).emit('guesses-update', {
      remainingGuesses: player.remainingGuesses
    });

    // âœ… Ø¥Ø°Ø§ Ø®Ù„ØµØª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§ØªØŒ Ø¹Ù„Ù‘Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙƒÙ€ "Ø®Ù„Øµ"
    if (player.remainingGuesses <= 0) {
      player.hasFinishedGuessing = true;
      console.log(`âŒ ${player.name} Ø®Ù„ØµØª Ù…Ø­Ø§ÙˆÙ„Ø§ØªÙ‡ ÙÙŠ Ø§Ù„ØºØ±ÙØ© ${roomId}`);
      
      // ğŸ” ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒÙ„ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø®Ù„ØµÙˆØ§
      checkRoundEnd(roomId);
    }
  }
});

  // ÙÙŠ Ù‚Ø³Ù… socket.on('player-ready')
socket.on('player-ready', ({ roomId, playerName, gameType, action }) => {
  console.log('ğŸ“¥ Ø§Ø³ØªÙ„Ø§Ù… player-ready:', { roomId, playerName, gameType, action });
  
  const room = rooms.get(roomId);
  
  if (!room) {
    console.error('âŒ Ø§Ù„ØºØ±ÙØ© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©:', roomId);
    return;
  }
  
  if (room.status !== 'finished') {
    console.error('âŒ Ø­Ø§Ù„Ø© Ø§Ù„ØºØ±ÙØ© Ù„ÙŠØ³Øª finished:', room.status);
    return;
  }

  // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ ÙŠØ±ÙŠØ¯ Ø§Ù„Ø®Ø±ÙˆØ¬
  if (action === 'leave') {
    room.players = room.players.filter(p => p.name !== playerName);
    
    if (room.players.length === 0) {
      rooms.delete(roomId);
      console.log(`ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„ØºØ±ÙØ© ${roomId}`);
    } else {
      io.to(roomId).emit('player-left', {
        playerName,
        remainingPlayers: room.players.length
      });
      
      io.to(roomId).emit('players-ready-update', {
        playersReady: room.playersReady,
        totalPlayers: room.players.length
      });
    }
    return;
  }

  // Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ¹Ø¯ÙŠÙ†
  if (!room.playersReady.includes(playerName)) {
    room.playersReady.push(playerName);
  }

  // Ø­ÙØ¸ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù‡ÙˆØ³Øª ÙÙ‚Ø·
  const hostName = room.players[0].name;
  if (playerName === hostName && gameType) {
    room.hostGameChoice = gameType;
  }

  console.log(`âœ“ ${playerName} Ù…Ø³ØªØ¹Ø¯ ÙÙŠ Ø§Ù„ØºØ±ÙØ© ${roomId}`);
  console.log(`ğŸ“Š Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ù…Ø³ØªØ¹Ø¯ÙŠÙ†:`, room.playersReady);

  io.to(roomId).emit('players-ready-update', {
    playersReady: room.playersReady,
    hostGameChoice: room.hostGameChoice || null,
    totalPlayers: room.players.length
  });

  // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ù…Ø³ØªØ¹Ø¯ÙŠÙ†
  if (room.playersReady.length === room.players.length) {
    console.log(`ğŸ® Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ù…Ø³ØªØ¹Ø¯ÙŠÙ† ÙÙŠ Ø§Ù„ØºØ±ÙØ© ${roomId}`);

    const selectedGameType = room.hostGameChoice || 'categories';
    console.log(`ğŸ² Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ù…Ø®ØªØ§Ø±Ø© Ù…Ù† Ø§Ù„Ù‡ÙˆØ³Øª: ${selectedGameType}`);

    room.status = 'waiting';
    room.gameType = selectedGameType;
    room.wordMode = 'player';
    room.currentCategory = 0;
    room.currentRound = 0;
    room.currentDrawer = 0;
    room.usedAnswers = [];
    room.drawingWords = [];
    room.guessedPlayers = [];
    room.playersReady = [];
    room.hostGameChoice = null;

    room.players.forEach(player => {
      player.score = 0;
      player.answers = [];
      player.remainingGuesses = 5;
      player.hasFinishedGuessing = false;
    });

    room.players.forEach(player => {
      io.to(player.id).emit('game-restarting', {
        roomId: roomId,
        gameType: selectedGameType,
        isHost: player.name === hostName
      });
    });

    console.log(`ğŸ”„ ØªÙ…Øª Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØºØ±ÙØ© ${roomId} - Ù†ÙˆØ¹ Ø§Ù„Ù„Ø¹Ø¨Ø©: ${selectedGameType}`);
  }
});

  socket.on('disconnect', () => {
    console.log('ğŸ”´ Ù„Ø§Ø¹Ø¨ ØºØ§Ø¯Ø±:', socket.id);
    
    const roomId = socket.roomId;
    if (roomId) {
      const room = rooms.get(roomId);
      if (room) {
        room.players = room.players.filter(p => p.id !== socket.id);
        
        if (room.players.length === 0) {
          rooms.delete(roomId);
          console.log(`ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„ØºØ±ÙØ© ${roomId}`);
        } else {
          io.to(roomId).emit('room-update', {
            players: room.players.map(p => ({ name: p.name, score: p.score || 0 })),
            status: room.status
          });
        }
      }
    }
  });
});

// ================ Helper Functions ================

function generateRoomId() {
  return Math.random().toString(36).substring(2, 8).toUpperCase();
}

setInterval(() => {
  const now = Date.now();
  for (const [roomId, room] of rooms.entries()) {
    if (now - room.createdAt > 600000) {
      rooms.delete(roomId);
      console.log(`ğŸ—‘ï¸ ØªÙ… Ø­Ø°Ù Ø§Ù„ØºØ±ÙØ© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© ${roomId}`);
    }
  }
}, 600000);

// ================ Start Server ================

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`ğŸš€ Ø§Ù„Ø³ÙŠØ±ÙØ± ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù†ÙØ° ${PORT}`);
});