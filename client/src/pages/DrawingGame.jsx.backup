import { useState, useEffect, useRef } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import socketService from '../services/socket';



function DrawingGame() {
    
  const location = useLocation();
  const navigate = useNavigate();
  const { roomId, playerName } = location.state || {};
  const [isNavigating, setIsNavigating] = useState(false);
  const canvasImageRef = useRef(null); // âœ… Ù„Ø­ÙØ¸ ØµÙˆØ±Ø© Canvas

  const [isDrawing, setIsDrawing] = useState(false);
  const [myTurn, setMyTurn] = useState(false);
  const [currentWord, setCurrentWord] = useState('');
  const [drawerName, setDrawerName] = useState('');
  const [timeLeft, setTimeLeft] = useState(60);
  const [round, setRound] = useState(1);
  const [totalRounds, setTotalRounds] = useState(1);
  const [guess, setGuess] = useState('');
  const [scores, setScores] = useState([]);
  const [messages, setMessages] = useState([]);
  const [color, setColor] = useState('#000000');
  const [brushSize, setBrushSize] = useState(3);
  const [remainingGuesses, setRemainingGuesses] = useState(5);
  const [isEraser, setIsEraser] = useState(false);
  const [showScores, setShowScores] = useState(false);
  const [feedbackMessage, setFeedbackMessage] = useState(null);
  const [gameEnded, setGameEnded] = useState(false);
  const [showLeaveConfirm, setShowLeaveConfirm] = useState(false);

  const canvasRef = useRef(null);
  const ctxRef = useRef(null);
  const timerRef = useRef(null);

  //const blocker = usePreventNavigation(!gameEnded);

  const colors = ['#000000', '#FF0000', '#0000FF', '#00FF00', '#FFFF00', '#FF00FF', '#00FFFF', '#FFFFFF'];

  // âœ… Ø¯Ø§Ù„Ø© Ù„Ø­ÙØ¸ Ù…Ø­ØªÙˆÙ‰ Canvas ÙƒØµÙˆØ±Ø©
  const saveCanvasImage = () => {
    const canvas = canvasRef.current;
    if (canvas) {
      try {
        canvasImageRef.current = canvas.toDataURL('image/png');
      } catch (error) {
        console.error('Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Canvas:', error);
      }
    }
  };

  // âœ… Ø¯Ø§Ù„Ø© Ù„Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù…Ø­ØªÙˆÙ‰ Canvas
  const restoreCanvasImage = () => {
    const canvas = canvasRef.current;
    const ctx = ctxRef.current;
    if (canvas && ctx && canvasImageRef.current) {
      const img = new Image();
      img.onload = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0);
      };
      img.src = canvasImageRef.current;
    }
  };

  const selectColor = (selectedColor) => {
    setColor(selectedColor);
    setIsEraser(false);
  };

  const selectEraser = () => {
    setIsEraser(true);
    setColor('#FFFFFF');
  };

  const showFeedback = (message, type) => {
    setFeedbackMessage({ message, type });
    setTimeout(() => setFeedbackMessage(null), 3000);
  };

  
    // âœ… Ù…Ù†Ø¹ pull-to-refresh ÙˆØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø©
    useEffect(() => {
    // Ù…Ù†Ø¹ pull-to-refresh
    let startY = 0;
    
    const preventPullToRefresh = (e) => {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        
        if (scrollTop === 0) {
        if (e.touches && e.touches.length > 0) {
            startY = e.touches[0].pageY;
        }
        }
    };

    const handleTouchMove = (e) => {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        
        if (scrollTop === 0 && e.touches && e.touches.length > 0) {
        const currentY = e.touches[0].pageY;
        
        // Ø¥Ø°Ø§ ÙƒØ§Ù† ÙŠØ³Ø­Ø¨ Ù„Ù„Ø£Ø³ÙÙ„ (refresh)
        if (currentY > startY) {
            e.preventDefault();
        }
        }
    };

    // Ù…Ù†Ø¹ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø© Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø­Ø¨ Ù„Ù„Ø£Ø³ÙÙ„
    document.addEventListener('touchstart', preventPullToRefresh, { passive: false });
    document.addEventListener('touchmove', handleTouchMove, { passive: false });

    // Ù…Ù†Ø¹ Ø§Ù„Ù€ scroll Ø¹Ù„Ù‰ Ø§Ù„ØµÙØ­Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
    document.body.style.overflow = 'hidden';
    document.body.style.position = 'fixed';
    document.body.style.width = '100%';
    document.body.style.height = '100%';

    return () => {
        document.removeEventListener('touchstart', preventPullToRefresh);
        document.removeEventListener('touchmove', handleTouchMove);
        
        // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù€ scroll Ø¹Ù†Ø¯ Ø§Ù„Ù…ØºØ§Ø¯Ø±Ø©
        document.body.style.overflow = '';
        document.body.style.position = '';
        document.body.style.width = '';
        document.body.style.height = '';
    };
    }, []);
    
    useEffect(() => {
        if (!gameEnded) {
            const handleBeforeUnload = (e) => {
            e.preventDefault();
            e.returnValue = '';
            };

            window.addEventListener('beforeunload', handleBeforeUnload);

            return () => {
            window.removeEventListener('beforeunload', handleBeforeUnload);
            };
        }
        }, [gameEnded]);

// Ø¥Ø¹Ø¯Ø§Ø¯ Canvas Ø¨Ø­Ø¬Ù… Ø«Ø§Ø¨Øª
    useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const setupCanvas = () => {
        const container = canvas.parentElement;
        const containerWidth = container.offsetWidth;
        
        // âœ… Ø­ÙØ¸ Ø§Ù„ØµÙˆØ±Ø© Ù‚Ø¨Ù„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯
        saveCanvasImage();
        
        const aspectRatio = 4 / 3;
        canvas.width = 800;
        canvas.height = 600;
        
        const displayHeight = containerWidth / aspectRatio;
        container.style.height = `${displayHeight}px`;

        const ctx = canvas.getContext('2d');
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctxRef.current = ctx;

        // âœ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„ØµÙˆØ±Ø© Ø¨Ø¹Ø¯ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯
        setTimeout(() => restoreCanvasImage(), 50);
    };

    setupCanvas();
    
    // âœ… ØªØ¹Ø¯ÙŠÙ„: Ù…Ù†Ø¹ resize Ø¹Ù„Ù‰ Ø§Ù„Ø¬ÙˆØ§Ù„ - ÙÙ‚Ø· Ù„Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±
    let resizeTimeout;
    const handleResize = () => {
        // ØªØ¬Ø§Ù‡Ù„ resize Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø¬Ù‡Ø²Ø© Ø§Ù„ØµØºÙŠØ±Ø© (Ø§Ù„Ø¬ÙˆØ§Ù„)
        if (window.innerWidth < 1024) {
        return; // âŒ Ù„Ø§ ØªÙØ¹Ù„ Ø´ÙŠØ¡ Ø¹Ù„Ù‰ Ø§Ù„Ø¬ÙˆØ§Ù„
        }
        
        // Ù„Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ± ÙÙ‚Ø·
        saveCanvasImage();
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
        setupCanvas();
        }, 200); // Ø§Ù†ØªØ¸Ø§Ø± 200ms Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ resize
    };
    
    window.addEventListener('resize', handleResize);

    return () => {
        window.removeEventListener('resize', handleResize);
        clearTimeout(resizeTimeout);
    };
    }, []);

  // âœ… Ø­ÙØ¸ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ø´ÙƒÙ„ Ø¯ÙˆØ±ÙŠ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø±Ø³Ù…
  useEffect(() => {
    if (!myTurn) return;

    const saveInterval = setInterval(() => {
      saveCanvasImage();
    }, 2000); // Ø­ÙØ¸ ÙƒÙ„ Ø«Ø§Ù†ÙŠØªÙŠÙ†

    return () => clearInterval(saveInterval);
  }, [myTurn]);

  // âœ… Ù…Ù†Ø¹ Ù…Ø³Ø­ Canvas Ø¹Ù†Ø¯ scroll Ø£Ùˆ visibility change
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === 'visible') {
        setTimeout(() => restoreCanvasImage(), 100);
      } else {
        saveCanvasImage();
      }
    };

    const handleScroll = () => {
      saveCanvasImage();
      setTimeout(() => restoreCanvasImage(), 150);
    };

    // âœ… Ù…Ø¹Ø§Ù„Ø¬Ø© orientation change Ù„Ù„Ø¬ÙˆØ§Ù„
    const handleOrientationChange = () => {
      saveCanvasImage();
      setTimeout(() => restoreCanvasImage(), 300);
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('scroll', handleScroll, { passive: true });
    window.addEventListener('orientationchange', handleOrientationChange);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('scroll', handleScroll);
      window.removeEventListener('orientationchange', handleOrientationChange);
    };
  }, []);

  // Socket Events
  useEffect(() => {
    if (!roomId || !playerName) {
      navigate('/');
      return;
    }

    const socket = socketService.connect();

    socket.emit('get-scores', { roomId });
    socket.emit('request-drawing-state', { roomId });

    socket.on('scores-update', (data) => {
      setScores(data.scores.sort((a, b) => b.score - a.score));
    });

    socket.on('your-turn-to-draw', (data) => {
      setMyTurn(true);
      setCurrentWord(data.word);
      setRound(data.round);
      setTotalRounds(data.totalRounds);
      setTimeLeft(60);
      setMessages([]);
      setRemainingGuesses(5);
      clearCanvas();

      if (timerRef.current) clearInterval(timerRef.current);
      timerRef.current = setInterval(() => {
        setTimeLeft(prev => {
          if (prev <= 1) {
            clearInterval(timerRef.current);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    });

    socket.on('someone-drawing', (data) => {
      setMyTurn(false);
      setDrawerName(data.drawerName);
      setRound(data.round);
      setTotalRounds(data.totalRounds);
      setTimeLeft(60);
      setMessages([]);
      setRemainingGuesses(5);
      clearCanvas();

      if (timerRef.current) clearInterval(timerRef.current);
      timerRef.current = setInterval(() => {
        setTimeLeft(prev => {
          if (prev <= 1) {
            clearInterval(timerRef.current);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);
    });

    socket.on('drawing', (data) => {
      if (!ctxRef.current) return;
      const ctx = ctxRef.current;

      ctx.strokeStyle = data.color;
      ctx.lineWidth = data.brushSize;

      if (data.type === 'start') {
        ctx.beginPath();
        ctx.moveTo(data.x, data.y);
      } else if (data.type === 'draw') {
        ctx.lineTo(data.x, data.y);
        ctx.stroke();
        
        // âœ… Ø­ÙØ¸ Ø¨Ø¹Ø¯ ÙƒÙ„ Ø­Ø±ÙƒØ© Ø±Ø³Ù… Ù…Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ø¢Ø®Ø±ÙŠÙ†
        saveCanvasImage();
      }
    });

    socket.on('canvas-cleared', () => {
      clearCanvas();
    });

    socket.on('correct-guess', (data) => {
      setMessages(prev => [{
        type: 'correct',
        playerName: data.playerName,
        message: 'âœ… Ø®Ù…Ù‘Ù† Ø§Ù„ÙƒÙ„Ù…Ø© Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­!',
        id: Date.now()
      }, ...prev]);

      setScores(data.scores.sort((a, b) => b.score - a.score));
      
      if (data.playerName === playerName) {
        showFeedback('âœ… Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø©! +1 Ù†Ù‚Ø·Ø©', 'success');
      }
    });

    socket.on('wrong-guess', (data) => {
      setMessages(prev => [{
        type: 'wrong',
        playerName: data.playerName,
        message: data.guess,
        remainingGuesses: data.remainingGuesses,
        id: Date.now()
      }, ...prev.slice(0, 9)]);
    });

    socket.on('guesses-update', (data) => {
      setRemainingGuesses(data.remainingGuesses);
    });

    socket.on('no-guesses-left', (data) => {
      setMessages(prev => [{
        type: 'error',
        message: data.message,
        id: Date.now()
      }, ...prev]);
      showFeedback('âŒ Ø§Ù†ØªÙ‡Øª Ù…Ø­Ø§ÙˆÙ„Ø§ØªÙƒ!', 'error');
    });

    socket.on('round-ended', (data) => {
      if (timerRef.current) clearInterval(timerRef.current);
      
      setMessages(prev => [{
        type: 'info',
        message: `Ø§Ù„ÙƒÙ„Ù…Ø© ÙƒØ§Ù†Øª: ${data.word}`,
        id: Date.now()
      }, ...prev]);

      setScores(data.scores.sort((a, b) => b.score - a.score));
      showFeedback(`Ø§Ù„ÙƒÙ„Ù…Ø© ÙƒØ§Ù†Øª: ${data.word}`, 'info');
    });

    socket.on('game-finished', (data) => {
      console.log('ğŸ Ø§Ø³ØªÙ„Ø§Ù… game-finished ÙÙŠ DrawingGame:', data);
      
      if (isNavigating) {
        console.log('âš ï¸ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨Ø§Ù„ÙØ¹Ù„ØŒ ØªØ¬Ø§Ù‡Ù„ Ø§Ù„Ø­Ø¯Ø« Ø§Ù„Ù…ÙƒØ±Ø±');
        return;
      }
      
      if (timerRef.current) clearInterval(timerRef.current);
      setGameEnded(true);
      setIsNavigating(true);

      if (!data.results || !data.roomId) {
        console.error('âŒ Ø¨ÙŠØ§Ù†Ø§Øª Ù†Ø§Ù‚ØµØ© ÙÙŠ game-finished:', data);
        setIsNavigating(false);
        return;
      }

      let isHostValue = data.isHost;
      if (isHostValue === undefined && data.hostName) {
        isHostValue = playerName === data.hostName;
        console.log(`ğŸ” ØªÙ… Ø­Ø³Ø§Ø¨ isHost Ù…Ù† hostName: ${isHostValue}`);
      }

      console.log('ğŸš€ Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„Ù†ØªØ§Ø¦Ø¬:', {
        results: data.results,
        playerName,
        roomId: data.roomId,
        isHost: isHostValue
      });

      setTimeout(() => {
        navigate('/results', { 
          state: { 
            results: data.results,
            playerName: playerName,
            roomId: data.roomId,
            isHost: isHostValue || false
          },
          replace: true
        });
      }, 100);
    });

    return () => {
      socket.off('scores-update');
      socket.off('your-turn-to-draw');
      socket.off('someone-drawing');
      socket.off('drawing');
      socket.off('canvas-cleared');
      socket.off('correct-guess');
      socket.off('wrong-guess');
      socket.off('guesses-update');
      socket.off('no-guesses-left');
      socket.off('round-ended');
      socket.off('game-finished');
      if (timerRef.current) clearInterval(timerRef.current);
    };
  }, [roomId, playerName, navigate, isNavigating]);

  useEffect(() => {
    if (!gameEnded) {
      const handleBeforeLeave = (e) => {
        e.preventDefault();
        setShowLeaveConfirm(true);
      };
    }
  }, [gameEnded]);

  const handleConfirmLeave = () => {
    setGameEnded(true);
    setShowLeaveConfirm(false);
    
    socketService.emit('player-leave', { roomId, playerName });
    socketService.disconnect();
    
    navigate('/');
  };

  const handleCancelLeave = () => {
    setShowLeaveConfirm(false);
    
  };

  const getCanvasCoordinates = (e) => {
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    
    let clientX, clientY;
    
    if (e.touches && e.touches[0]) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    
    const x = (clientX - rect.left) * scaleX;
    const y = (clientY - rect.top) * scaleY;
    
    return { x, y };
  };

  const startDrawing = (e) => {
    if (!myTurn) return;
    e.preventDefault();
    
    const { x, y } = getCanvasCoordinates(e);

    setIsDrawing(true);
    const drawColor = isEraser ? '#FFFFFF' : color;
    ctxRef.current.strokeStyle = drawColor;
    ctxRef.current.lineWidth = isEraser ? brushSize * 3 : brushSize;
    ctxRef.current.beginPath();
    ctxRef.current.moveTo(x, y);

    socketService.emit('draw', {
      roomId,
      drawData: { type: 'start', x, y, color: drawColor, brushSize: isEraser ? brushSize * 3 : brushSize }
    });
  };

  const draw = (e) => {
    if (!isDrawing || !myTurn) return;
    e.preventDefault();

    const { x, y } = getCanvasCoordinates(e);

    ctxRef.current.lineTo(x, y);
    ctxRef.current.stroke();

    const drawColor = isEraser ? '#FFFFFF' : color;
    socketService.emit('draw', {
      roomId,
      drawData: { type: 'draw', x, y, color: drawColor, brushSize: isEraser ? brushSize * 3 : brushSize }
    });
  };

  const stopDrawing = () => {
    setIsDrawing(false);
    saveCanvasImage(); // âœ… Ø­ÙØ¸ Ø¹Ù†Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„Ø±Ø³Ù…
  };

  const clearCanvas = () => {
    const canvas = canvasRef.current;
    const ctx = ctxRef.current;
    if (!canvas || !ctx) return;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // âœ… Ù…Ø³Ø­ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø© Ø£ÙŠØ¶Ø§Ù‹
    canvasImageRef.current = null;
  };

  const handleClear = () => {
    if (!myTurn) return;
    clearCanvas();
    socketService.emit('clear-canvas', { roomId });
  };

  const handleGuess = (e) => {
    e.preventDefault();
    if (!guess.trim() || myTurn || remainingGuesses <= 0) return;

    socketService.emit('submit-guess', { guess: guess.trim() });
    
    showFeedback('âŒ Ø¥Ø¬Ø§Ø¨Ø© Ø®Ø§Ø·Ø¦Ø©', 'error');
    
    setGuess('');
  };

  return (
    <div className="min-h-screen w-full bg-gradient-to-br from-purple-600 to-indigo-600 flex items-center justify-center p-4">
      
        <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 z-40 lg:top-4 lg:left-4 lg:translate-x-0">
            <button
                onClick={() => setShowLeaveConfirm(true)}
                className="bg-red-500 text-white px-6 py-3 rounded-xl font-bold hover:bg-red-600 shadow-lg"
            >
                ğŸšª Ù…ØºØ§Ø¯Ø±Ø©
            </button>
        </div>

      {showLeaveConfirm && (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-2xl p-8 max-w-md w-full shadow-2xl">
            <div className="text-center mb-6">
              <div className="text-6xl mb-4">âš ï¸</div>
              <h2 className="text-2xl font-bold text-gray-800 mb-3">
                Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ù…ØºØ§Ø¯Ø±Ø©ØŸ
              </h2>
              <p className="text-gray-600">
                Ø¥Ø°Ø§ ØºØ§Ø¯Ø±Øª Ø§Ù„Ø¢Ù† Ø³ÙŠØªÙ… ÙÙ‚Ø¯Ø§Ù† ØªÙ‚Ø¯Ù…Ùƒ ÙÙŠ Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆØ³ÙŠØ¤Ø«Ø± Ø°Ù„Ùƒ Ø¹Ù„Ù‰ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ø¢Ø®Ø±ÙŠÙ†.
              </p>
            </div>
            
            <div className="flex gap-3">
              <button
                onClick={handleCancelLeave}
                className="flex-1 bg-green-500 text-white px-6 py-3 rounded-xl font-bold hover:bg-green-600 transition-colors"
              >
                âœ… Ø§Ù„Ø¨Ù‚Ø§Ø¡ ÙÙŠ Ø§Ù„Ù„Ø¹Ø¨Ø©
              </button>
              <button
                onClick={handleConfirmLeave}
                className="flex-1 bg-red-500 text-white px-6 py-3 rounded-xl font-bold hover:bg-red-600 transition-colors"
              >
                ğŸšª Ù…ØºØ§Ø¯Ø±Ø©
              </button>
            </div>
          </div>
        </div>
      )}

      {feedbackMessage && (
        <div className={`fixed top-4 left-1/2 transform -translate-x-1/2 z-50 px-6 py-4 rounded-xl shadow-2xl font-bold text-lg animate-bounce ${
          feedbackMessage.type === 'success' ? 'bg-green-500 text-white' :
          feedbackMessage.type === 'error' ? 'bg-red-500 text-white' :
          'bg-blue-500 text-white'
        }`}>
          {feedbackMessage.message}
        </div>
      )}

      <div className={`lg:hidden fixed inset-y-0 right-0 w-64 bg-white shadow-2xl transform transition-transform duration-300 z-40 ${
        showScores ? 'translate-x-0' : 'translate-x-full'
      }`}>
        <div className="p-4">
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-lg font-bold text-gray-800">ğŸ“Š Ø§Ù„Ù†Ù‚Ø§Ø·</h3>
            <button
              onClick={() => setShowScores(false)}
              className="text-gray-600 hover:text-gray-800 text-2xl"
            >
              âœ•
            </button>
          </div>
          <div className="space-y-2">
            {scores.map((player, index) => (
              <div
                key={player.name}
                className={`flex items-center justify-between p-3 rounded-lg ${
                  player.name === playerName ? 'bg-pink-100 border-2 border-pink-300' : 'bg-gray-50'
                }`}
              >
                <div className="flex items-center gap-2">
                  {index === 0 && <span className="text-xl">ğŸ‘‘</span>}
                  <span className="font-semibold text-sm">{player.name}</span>
                </div>
                <span className="text-lg font-bold text-pink-600">
                  {player.score}
                </span>
              </div>
            ))}
          </div>
        </div>
      </div>

      {showScores && (
        <div
          className="lg:hidden fixed inset-0 bg-black bg-opacity-50 z-30"
          onClick={() => setShowScores(false)}
        />
      )}

      <div className="max-w-7xl mx-auto p-2 sm:p-4">
        <div className="grid grid-cols-1 lg:grid-cols-4 gap-3 sm:gap-6">
          
          <div className="lg:col-span-3">
            <div className="card p-3 sm:p-6">
              <div className="flex items-center justify-between mb-3">
                <div className="flex-1">
                  <h2 className="text-base sm:text-xl font-bold text-gray-800 truncate">
                    {myTurn ? (
                      <>ğŸ¨ Ø§Ø±Ø³Ù…: <span className="text-pink-600">{currentWord}</span></>
                    ) : (
                      <>ğŸ‘€ ÙŠØ±Ø³Ù…: <span className="text-pink-600">{drawerName}</span></>
                    )}
                  </h2>
                  <p className="text-xs text-gray-600">
                    Ø§Ù„Ø¬ÙˆÙ„Ø© {round} Ù…Ù† {totalRounds}
                  </p>
                </div>
                
                <div className="flex items-center gap-2">
                  <div className={`text-xl sm:text-3xl font-bold ${timeLeft <= 10 ? 'text-red-500 animate-pulse' : 'text-green-500'}`}>
                    â±ï¸ {timeLeft}
                  </div>
                  
                  <button
                    onClick={() => setShowScores(true)}
                    className="lg:hidden bg-pink-600 text-white px-3 py-2 rounded-lg font-bold"
                  >
                    ğŸ“Š
                  </button>
                </div>
              </div>

              {myTurn && (
                <div className="flex items-center gap-2 mb-3 p-2 bg-gray-50 rounded-xl overflow-x-auto">
                  <div className="flex gap-1">
                    {colors.map(c => (
                      <button
                        key={c}
                        onClick={() => selectColor(c)}
                        className={`w-7 h-7 sm:w-8 sm:h-8 rounded-full border-2 transition-transform flex-shrink-0 ${
                          color === c && !isEraser ? 'border-gray-800 scale-110' : 'border-gray-300'
                        }`}
                        style={{ backgroundColor: c }}
                      />
                    ))}
                  </div>

                  <button
                    onClick={selectEraser}
                    className={`px-3 py-1 rounded-lg font-semibold text-xs whitespace-nowrap flex-shrink-0 ${
                      isEraser 
                        ? 'bg-purple-500 text-white' 
                        : 'bg-white text-purple-700 border-2 border-purple-300'
                    }`}
                  >
                    ğŸ§¹
                  </button>

                  <div className="flex gap-1 border-r border-l border-gray-300 px-2">
                    {[2, 5, 10].map(size => (
                      <button
                        key={size}
                        onClick={() => setBrushSize(size)}
                        className={`w-7 h-7 rounded-lg flex items-center justify-center flex-shrink-0 ${
                          brushSize === size ? 'bg-pink-500 text-white' : 'bg-white text-gray-700'
                        }`}
                      >
                        <div 
                          className="rounded-full bg-current" 
                          style={{ width: size + 2, height: size + 2 }}
                        />
                      </button>
                    ))}
                  </div>

                  <button
                    onClick={handleClear}
                    className="px-3 py-1 bg-red-500 text-white rounded-lg font-semibold text-xs whitespace-nowrap flex-shrink-0"
                  >
                    ğŸ—‘ï¸
                  </button>
                </div>
              )}

              <div className="relative w-full bg-gray-200 rounded-xl overflow-hidden">
                <canvas
                  ref={canvasRef}
                  onMouseDown={startDrawing}
                  onMouseMove={draw}
                  onMouseUp={stopDrawing}
                  onMouseLeave={stopDrawing}
                  onTouchStart={startDrawing}
                  onTouchMove={draw}
                  onTouchEnd={stopDrawing}
                  className={`w-full h-full border-4 border-gray-300 bg-white ${
                    isEraser ? 'cursor-cell' : 'cursor-crosshair'
                  }`}
                  style={{ 
                    touchAction: 'none',
                    display: 'block',
                    willChange: 'transform',
                    backfaceVisibility: 'hidden'
                  }}
                />
              </div>

              {!myTurn && (
                <div className="mt-3">
                  <div className={`mb-3 p-3 rounded-xl text-center font-bold text-lg ${
                    remainingGuesses <= 2 ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'
                  }`}>
                    ğŸ’­ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©: {remainingGuesses} / 5
                  </div>

                  <form onSubmit={handleGuess}>
                    <div className="flex flex-col gap-2">
                      <input
                        type="text"
                        value={guess}
                        onChange={(e) => setGuess(e.target.value)}
                        placeholder={remainingGuesses > 0 ? "Ø§ÙƒØªØ¨ ØªØ®Ù…ÙŠÙ†Ùƒ..." : "Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª!"}
                        className="input-field text-lg py-4 text-center"
                        disabled={remainingGuesses <= 0}
                        autoFocus
                      />
                      <button
                        type="submit"
                        disabled={!guess.trim() || remainingGuesses <= 0}
                        className="bg-pink-600 text-white px-6 py-4 rounded-xl font-bold text-lg hover:bg-pink-700 disabled:opacity-50 disabled:cursor-not-allowed shadow-lg"
                      >
                        ğŸ“¤ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªØ®Ù…ÙŠÙ†
                      </button>
                    </div>
                  </form>
                </div>
              )}
            </div>
          </div>

          <div className="hidden lg:block space-y-6">
            <div className="card p-6">
              <h3 className="text-lg font-bold text-gray-800 mb-4 text-center">
                ğŸ“Š Ø§Ù„Ù†Ù‚Ø§Ø·
              </h3>
              <div className="space-y-3">
                {scores.map((player, index) => (
                  <div
                    key={player.name}
                    className={`flex items-center justify-between p-3 rounded-lg transition-all ${
                      player.name === playerName ? 'bg-pink-100 border-2 border-pink-300' : 'bg-gray-50'
                    }`}
                  >
                    <div className="flex items-center gap-2">
                      {index === 0 && <span className="text-xl">ğŸ‘‘</span>}
                      <span className="font-semibold">{player.name}</span>
                    </div>
                    <span className="text-xl font-bold text-pink-600">
                      {player.score}
                    </span>
                  </div>
                ))}
              </div>
            </div>

            <div className="card p-6">
              <h3 className="text-lg font-bold text-gray-800 mb-4 text-center">
                ğŸ’¬ Ø§Ù„ØªØ®Ù…ÙŠÙ†Ø§Øª
              </h3>
              <div className="space-y-3 max-h-96 overflow-y-auto">
                {messages.length === 0 ? (
                  <p className="text-center text-gray-500 text-sm py-8">
                    Ù„Ø§ ØªÙˆØ¬Ø¯ ØªØ®Ù…ÙŠÙ†Ø§Øª Ø¨Ø¹Ø¯...
                  </p>
                ) : (
                  messages.map((msg) => (
                    <div
                      key={msg.id}
                      className={`p-3 rounded-lg ${
                        msg.type === 'correct' ? 'bg-green-50' :
                        msg.type === 'info' ? 'bg-blue-50' :
                        msg.type === 'error' ? 'bg-red-50' :
                        'bg-gray-50'
                      }`}
                    >
                      {msg.type === 'correct' ? (
                        <div className="flex items-center justify-between">
                          <span className="font-semibold text-green-700 text-sm">
                            ğŸ‘¤ {msg.playerName}
                          </span>
                          <span className="text-green-600 font-bold">âœ…</span>
                        </div>
                      ) : msg.type === 'info' ? (
                        <p className="text-center font-bold text-blue-700 text-sm">
                          {msg.message}
                        </p>
                      ) : msg.type === 'error' ? (
                        <p className="text-center font-bold text-red-700 text-sm">
                          âš ï¸ {msg.message}
                        </p>
                      ) : (
                        <div>
                          <div className="flex items-center justify-between mb-2">
                            <span className="font-semibold text-gray-700 text-sm">
                              ğŸ‘¤ {msg.playerName}
                            </span>
                            <span className={`text-xs font-bold px-2 py-1 rounded ${
                              msg.remainingGuesses <= 2 
                                ? 'bg-red-100 text-red-700' 
                                : 'bg-blue-100 text-blue-700'
                            }`}>
                              {msg.remainingGuesses} / 5 ğŸ’­
                            </span>
                          </div>
                          <span className="text-gray-600 text-sm">{msg.message}</span>
                        </div>
                      )}
                    </div>
                  ))
                )}
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

export default DrawingGame;